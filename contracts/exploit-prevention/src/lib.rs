
#![no_std]

use soroban_sdk::{
    contract, contractimpl, contracttype, log,
    symbol_short,
    Address, Bytes, BytesN, Env, Symbol,
};

// ─── Errors ──────────────────────────────────────────────────────────────────

use soroban_sdk::contracterror;

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum ExploitError {
    Unauthorized           = 1,
    NotAdmin               = 2,
    NotOracle              = 3,
    AlreadyProcessed       = 10,
    NonceReused            = 11,
    InvalidInput           = 20,
    AmountTooLow           = 21,
    AmountTooHigh          = 22,
    StaleTimestamp         = 24,
    InvalidStateTransition = 30,
    AlreadyInitialized     = 31,
    NotInitialized         = 32,
    ContractPaused         = 33,
    ArithmeticOverflow     = 40,
    InsufficientBalance    = 41,
    AccountingInvariant    = 42,
    InvalidRngProof        = 50,
    OracleDataTampered     = 51,
    SettlementManipulated  = 52,
    RateLimitExceeded      = 60,
}

// ─── Storage Keys ────────────────────────────────────────────────────────────

#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    Admin,
    Oracle,
    Paused,
    BoundConfig,
    Nonce(u64),
    TxHash(BytesN<32>),
    RateLimit(Address),
}

// ─── Data Structs ────────────────────────────────────────────────────────────

#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BoundConfig {
    pub min_amount: i128,
    pub max_amount: i128,
    pub max_timestamp_delta: u64,
    pub rate_limit_window: u64
    pub rate_limit_max_calls: u32,
}

#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RateLimitEntry {
    pub window_start: u64,
    pub call_count: u32,
}

// ─── Contract ────────────────────────────────────────────────────────────────

#[contract]
pub struct ExploitPreventionContract;

#[contractimpl]
impl ExploitPreventionContract {
    // ── Initialization ──────────────────────────────────────────────────────

    pub fn initialize(
        env: Env,
        admin: Address,
        oracle: Address,
        config: BoundConfig,
    ) -> Result<(), ExploitError> {
        if env.storage().instance().has(&DataKey::Admin) {
            return Err(ExploitError::AlreadyInitialized);
        }

        Self::validate_bound_config(&config)?;

        env.storage().instance().set(&DataKey::Admin, &admin);
        env.storage().instance().set(&DataKey::Oracle, &oracle);
        env.storage().instance().set(&DataKey::Paused, &false);
        env.storage().instance().set(&DataKey::BoundConfig, &config);

        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("init")),
            (admin,),
        );

        Ok(())
    }

    // ── Admin / Access Control ───────────────────────────────────────────────

    pub fn change_admin(
        env: Env,
        caller: Address,
        new_admin: Address,
    ) -> Result<(), ExploitError> {
        caller.require_auth();
        let admin = Self::require_admin(&env, &caller)?;
        env.storage().instance().set(&DataKey::Admin, &new_admin);
        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("adm_chg")),
            (admin, new_admin),
        );
        Ok(())
    }

    /// Update the oracle address (admin only).
    pub fn set_oracle(
        env: Env,
        caller: Address,
        new_oracle: Address,
    ) -> Result<(), ExploitError> {
        caller.require_auth();
        Self::require_admin(&env, &caller)?;
        env.storage().instance().set(&DataKey::Oracle, &new_oracle);
        Ok(())
    }

    pub fn update_bounds(
        env: Env,
        caller: Address,
        config: BoundConfig,
    ) -> Result<(), ExploitError> {
        caller.require_auth();
        Self::require_admin(&env, &caller)?;
        Self::validate_bound_config(&config)?;
        env.storage().instance().set(&DataKey::BoundConfig, &config);
        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("bnd_upd")),
            (),
        );
        Ok(())
    }

    // ── Emergency Pause ──────────────────────────────────────────────────────

    pub fn pause(env: Env, caller: Address) -> Result<(), ExploitError> {
        caller.require_auth();
        let admin = Self::require_admin(&env, &caller)?;
        env.storage().instance().set(&DataKey::Paused, &true);
        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("paused")),
            (admin,),
        );
        Ok(())
    }

    pub fn unpause(env: Env, caller: Address) -> Result<(), ExploitError> {
        caller.require_auth();
        let admin = Self::require_admin(&env, &caller)?;
        env.storage().instance().set(&DataKey::Paused, &false);
        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("unpaused")),
            (admin,),
        );
        Ok(())
    }

    // ── Replay Protection ────────────────────────────────────────────────────

    pub fn consume_nonce(env: Env, nonce: u64) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        let key = DataKey::Nonce(nonce);
        if env.storage().persistent().has(&key) {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("rply_blk")),
                (nonce,),
            );
            return Err(ExploitError::NonceReused);
        }
        env.storage().persistent().set(&key, &true);
        // Keep nonce records for at least 7 days (in ledgers: ~7*24*60*60/5 ≈ 120960)
        env.storage().persistent().extend_ttl(&key, 120960, 120960);
        Ok(())
    }

    pub fn consume_tx_hash(env: Env, hash: BytesN<32>) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        let key = DataKey::TxHash(hash.clone());
        if env.storage().persistent().has(&key) {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("rply_blk")),
                (hash,),
            );
            return Err(ExploitError::AlreadyProcessed);
        }
        env.storage().persistent().set(&key, &true);
        env.storage().persistent().extend_ttl(&key, 120960, 120960);
        Ok(())
    }

    // ── Input Bounds Validation ───────────────────────────────────────────────

    pub fn check_amount(env: Env, amount: i128) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        let config = Self::get_config(&env)?;
        if amount < config.min_amount {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("bnd_viol")),
                (amount, config.min_amount, config.max_amount),
            );
            return Err(ExploitError::AmountTooLow);
        }
        if amount > config.max_amount {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("bnd_viol")),
                (amount, config.min_amount, config.max_amount),
            );
            return Err(ExploitError::AmountTooHigh);
        }
        Ok(())
    }

    pub fn check_timestamp(env: Env, timestamp: u64) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        let config = Self::get_config(&env)?;
        let now = env.ledger().timestamp();

        // Reject future timestamps (more than 30s ahead) to prevent pre-signing
        if timestamp > now.saturating_add(30) {
            return Err(ExploitError::StaleTimestamp);
        }

        let age = now.saturating_sub(timestamp);
        if age > config.max_timestamp_delta {
            return Err(ExploitError::StaleTimestamp);
        }
        Ok(())
    }

    // ── Rate Limiting ────────────────────────────────────────────────────────

    pub fn check_rate_limit(env: Env, caller: Address) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        let config = Self::get_config(&env)?;
        let now = env.ledger().timestamp();
        let key = DataKey::RateLimit(caller.clone());

        let entry: RateLimitEntry = env
            .storage()
            .temporary()
            .get(&key)
            .unwrap_or(RateLimitEntry { window_start: now, call_count: 0 });

        // Reset window if expired
        let (window_start, call_count) =
            if now.saturating_sub(entry.window_start) >= config.rate_limit_window {
                (now, 0u32)
            } else {
                (entry.window_start, entry.call_count)
            };

        if call_count >= config.rate_limit_max_calls {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("rt_lmt")),
                (caller,),
            );
            return Err(ExploitError::RateLimitExceeded);
        }

        let new_entry = RateLimitEntry {
            window_start,
            call_count: call_count.saturating_add(1),
        };
        env.storage().temporary().set(&key, &new_entry);
        // Keep for the duration of the rate-limit window (approximate in ledgers)
        let window_ledgers = (config.rate_limit_window / 5).max(1) as u32;
        env.storage().temporary().extend_ttl(&key, window_ledgers, window_ledgers);

        Ok(())
    }

    // ── Randomness Integrity ─────────────────────────────────────────────────

    pub fn validate_rng_proof(
        env: Env,
        caller: Address,
        game_id: u64,
        vrf_output: BytesN<32>,
        vrf_proof: BytesN<32>,
    ) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        caller.require_auth();

        let mut preimage = Bytes::new(&env);
        preimage.extend_from_array(&game_id.to_be_bytes());
        preimage.append(&Bytes::from_slice(&env, vrf_output.as_ref()));

        let expected: BytesN<32> = env.crypto().sha256(&preimage);

        if expected != vrf_proof {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("rng_rej")),
                (game_id,),
            );
            return Err(ExploitError::InvalidRngProof);
        }

        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("rng_ok")),
            (game_id,),
        );
        Ok(())
    }

    // ── Oracle Data Integrity ─────────────────────────────────────────────────

    pub fn validate_oracle_data(
        env: Env,
        oracle_caller: Address,
        round_id: u64,
        data: Bytes,
        signature: BytesN<32>,
    ) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        oracle_caller.require_auth();
        Self::require_oracle(&env, &oracle_caller)?;

        // Compute expected: SHA-256(round_id || data)
        let mut preimage = Bytes::new(&env);
        preimage.extend_from_array(&round_id.to_be_bytes());
        preimage.append(&data);

        let expected: BytesN<32> = env.crypto().sha256(&preimage);

        if expected != signature {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("orc_rej")),
                (round_id,),
            );
            return Err(ExploitError::OracleDataTampered);
        }

        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("orc_ok")),
            (round_id,),
        );
        Ok(())
    }

    // ── Settlement Validation ────────────────────────────────────────────────

    pub fn validate_settlement(
        env: Env,
        caller: Address,
        pool_balance: i128,
        total_in: i128,
        total_out: i128,
        payout: i128,
    ) -> Result<(), ExploitError> {
        Self::require_not_paused(&env)?;
        caller.require_auth();

        // Basic non-negative invariants
        if total_in < 0 || total_out < 0 || pool_balance < 0 || payout < 0 {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("stl_rej")),
                (total_in, total_out),
            );
            return Err(ExploitError::InvalidInput);
        }

        // Total payouts must not exceed total wagers (house edge / break-even)
        if total_out > total_in {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("stl_rej")),
                (total_in, total_out),
            );
            return Err(ExploitError::SettlementManipulated);
        }

        // Individual payout must not exceed pool balance (solvency invariant)
        if payout > pool_balance {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("stl_rej")),
                (total_in, total_out),
            );
            return Err(ExploitError::InsufficientBalance);
        }

        let remaining = pool_balance
            .checked_sub(payout)
            .ok_or(ExploitError::ArithmeticOverflow)?;

        if remaining < 0 {
            env.events().publish(
                (symbol_short!("exploit"), symbol_short!("stl_rej")),
                (total_in, total_out),
            );
            return Err(ExploitError::AccountingInvariant);
        }

        env.events().publish(
            (symbol_short!("exploit"), symbol_short!("stl_ok")),
            (total_in, total_out),
        );
        Ok(())
    }

    // ── Getters ──────────────────────────────────────────────────────────────

    pub fn get_admin(env: Env) -> Result<Address, ExploitError> {
        env.storage()
            .instance()
            .get(&DataKey::Admin)
            .ok_or(ExploitError::NotInitialized)
    }

    pub fn is_paused(env: Env) -> bool {
        env.storage()
            .instance()
            .get::<_, bool>(&DataKey::Paused)
            .unwrap_or(false)
    }

    pub fn get_bound_config(env: Env) -> Result<BoundConfig, ExploitError> {
        Self::get_config(&env)
    }

    pub fn is_nonce_consumed(env: Env, nonce: u64) -> bool {
        env.storage().persistent().has(&DataKey::Nonce(nonce))
    }

    pub fn is_tx_hash_consumed(env: Env, hash: BytesN<32>) -> bool {
        env.storage().persistent().has(&DataKey::TxHash(hash))
    }

    // ── Private Helpers ──────────────────────────────────────────────────────

    fn require_admin(env: &Env, caller: &Address) -> Result<Address, ExploitError> {
        let admin: Address = env
            .storage()
            .instance()
            .get(&DataKey::Admin)
            .ok_or(ExploitError::NotInitialized)?;
        if *caller != admin {
            return Err(ExploitError::NotAdmin);
        }
        Ok(admin)
    }

    fn require_oracle(env: &Env, caller: &Address) -> Result<(), ExploitError> {
        let oracle: Address = env
            .storage()
            .instance()
            .get(&DataKey::Oracle)
            .ok_or(ExploitError::NotInitialized)?;
        if *caller != oracle {
            return Err(ExploitError::NotOracle);
        }
        Ok(())
    }

    fn require_not_paused(env: &Env) -> Result<(), ExploitError> {
        let paused: bool = env
            .storage()
            .instance()
            .get(&DataKey::Paused)
            .unwrap_or(false);
        if paused {
            Err(ExploitError::ContractPaused)
        } else {
            Ok(())
        }
    }

    fn get_config(env: &Env) -> Result<BoundConfig, ExploitError> {
        env.storage()
            .instance()
            .get(&DataKey::BoundConfig)
            .ok_or(ExploitError::NotInitialized)
    }

    fn validate_bound_config(config: &BoundConfig) -> Result<(), ExploitError> {
        if config.min_amount < 0 {
            return Err(ExploitError::InvalidInput);
        }
        if config.max_amount <= config.min_amount {
            return Err(ExploitError::InvalidInput);
        }
        if config.max_timestamp_delta == 0 {
            return Err(ExploitError::InvalidInput);
        }
        if config.rate_limit_window == 0 || config.rate_limit_max_calls == 0 {
            return Err(ExploitError::InvalidInput);
        }
        Ok(())
    }
}

// ─── Tests ────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use soroban_sdk::{
        testutils::{Address as _, Ledger, LedgerInfo},
        Bytes, BytesN, Env,
    };

    // ── Helpers ───────────────────────────────────────────────────────────────

    fn default_config() -> BoundConfig {
        BoundConfig {
            min_amount: 1_000_000,          // 0.1 XLM in stroops
            max_amount: 100_000_000_000,    // 10,000 XLM
            max_timestamp_delta: 300,       // 5 minutes
            rate_limit_window: 60,          // 1 minute
            rate_limit_max_calls: 10,
        }
    }

    fn setup() -> (Env, ExploitPreventionContractClient<'static>) {
        let env = Env::default();
        env.mock_all_auths();
        let contract_id = env.register(ExploitPreventionContract, ());
        let client = ExploitPreventionContractClient::new(&env, &contract_id);
        (env, client)
    }

    fn setup_initialized() -> (Env, ExploitPreventionContractClient<'static>, Address, Address) {
        let (env, client) = setup();
        let admin = Address::generate(&env);
        let oracle = Address::generate(&env);
        client
            .initialize(&admin, &oracle, &default_config())
            .unwrap();
        (env, client, admin, oracle)
    }

    // ── Initialization ────────────────────────────────────────────────────────

    #[test]
    fn test_initialize_success() {
        let (env, client) = setup();
        let admin = Address::generate(&env);
        let oracle = Address::generate(&env);
        let result = client.initialize(&admin, &oracle, &default_config());
        assert!(result.is_ok());
        assert_eq!(client.get_admin().unwrap(), admin);
        assert!(!client.is_paused());
    }

    #[test]
    fn test_initialize_twice_fails() {
        let (_, client, admin, oracle) = setup_initialized();
        let result = client.initialize(&admin, &oracle, &default_config());
        assert_eq!(result.unwrap_err(), ExploitError::AlreadyInitialized);
    }

    #[test]
    fn test_initialize_invalid_config_fails() {
        let (env, client) = setup();
        let admin = Address::generate(&env);
        let oracle = Address::generate(&env);
        let bad_config = BoundConfig {
            min_amount: 1000,
            max_amount: 500, // max < min → invalid
            max_timestamp_delta: 300,
            rate_limit_window: 60,
            rate_limit_max_calls: 10,
        };
        let result = client.initialize(&admin, &oracle, &bad_config);
        assert_eq!(result.unwrap_err(), ExploitError::InvalidInput);
    }

    // ── Admin / Access Control ─────────────────────────────────────────────────

    #[test]
    fn test_change_admin_success() {
        let (env, client, admin, _) = setup_initialized();
        let new_admin = Address::generate(&env);
        client.change_admin(&admin, &new_admin).unwrap();
        assert_eq!(client.get_admin().unwrap(), new_admin);
    }

    #[test]
    fn test_change_admin_unauthorized() {
        let (env, client, _, _) = setup_initialized();
        let rando = Address::generate(&env);
        let new_admin = Address::generate(&env);
        let result = client.change_admin(&rando, &new_admin);
        assert_eq!(result.unwrap_err(), ExploitError::NotAdmin);
    }

    // ── Pause / Unpause ───────────────────────────────────────────────────────

    #[test]
    fn test_pause_unpause() {
        let (_, client, admin, _) = setup_initialized();
        client.pause(&admin).unwrap();
        assert!(client.is_paused());
        client.unpause(&admin).unwrap();
        assert!(!client.is_paused());
    }

    #[test]
    fn test_pause_blocks_operations() {
        let (_, client, admin, _) = setup_initialized();
        client.pause(&admin).unwrap();
        let result = client.consume_nonce(&42u64);
        assert_eq!(result.unwrap_err(), ExploitError::ContractPaused);
    }

    #[test]
    fn test_pause_unauthorized() {
        let (env, client, _, _) = setup_initialized();
        let rando = Address::generate(&env);
        let result = client.pause(&rando);
        assert_eq!(result.unwrap_err(), ExploitError::NotAdmin);
    }

    // ── Replay Protection ─────────────────────────────────────────────────────

    #[test]
    fn test_consume_nonce_success() {
        let (_, client, _, _) = setup_initialized();
        assert!(client.consume_nonce(&1u64).is_ok());
        assert!(client.is_nonce_consumed(&1u64));
    }

    #[test]
    fn test_consume_nonce_duplicate_fails() {
        let (_, client, _, _) = setup_initialized();
        client.consume_nonce(&99u64).unwrap();
        let result = client.consume_nonce(&99u64);
        assert_eq!(result.unwrap_err(), ExploitError::NonceReused);
    }

    #[test]
    fn test_consume_tx_hash_success() {
        let (env, client, _, _) = setup_initialized();
        let hash: BytesN<32> = BytesN::from_array(&env, &[1u8; 32]);
        assert!(client.consume_tx_hash(&hash).is_ok());
        assert!(client.is_tx_hash_consumed(&hash));
    }

    #[test]
    fn test_consume_tx_hash_duplicate_fails() {
        let (env, client, _, _) = setup_initialized();
        let hash: BytesN<32> = BytesN::from_array(&env, &[2u8; 32]);
        client.consume_tx_hash(&hash).unwrap();
        let result = client.consume_tx_hash(&hash);
        assert_eq!(result.unwrap_err(), ExploitError::AlreadyProcessed);
    }

    // ── Input Bounds ──────────────────────────────────────────────────────────

    #[test]
    fn test_check_amount_valid() {
        let (_, client, _, _) = setup_initialized();
        assert!(client.check_amount(&1_000_000i128).is_ok());
        assert!(client.check_amount(&50_000_000_000i128).is_ok());
    }

    #[test]
    fn test_check_amount_too_low() {
        let (_, client, _, _) = setup_initialized();
        let result = client.check_amount(&999_999i128);
        assert_eq!(result.unwrap_err(), ExploitError::AmountTooLow);
    }

    #[test]
    fn test_check_amount_too_high() {
        let (_, client, _, _) = setup_initialized();
        let result = client.check_amount(&100_000_000_001i128);
        assert_eq!(result.unwrap_err(), ExploitError::AmountTooHigh);
    }

    #[test]
    fn test_check_timestamp_valid() {
        let (env, client, _, _) = setup_initialized();
        let now = env.ledger().timestamp();
        assert!(client.check_timestamp(&now).is_ok());
        assert!(client.check_timestamp(&(now - 100)).is_ok());
    }

    #[test]
    fn test_check_timestamp_stale() {
        let (env, client, _, _) = setup_initialized();
        let now = env.ledger().timestamp();
        let stale = now - 301; // beyond 300s window
        let result = client.check_timestamp(&stale);
        assert_eq!(result.unwrap_err(), ExploitError::StaleTimestamp);
    }

    #[test]
    fn test_check_timestamp_future_rejected() {
        let (env, client, _, _) = setup_initialized();
        let now = env.ledger().timestamp();
        let future = now + 60; // 60s in the future → rejected
        let result = client.check_timestamp(&future);
        assert_eq!(result.unwrap_err(), ExploitError::StaleTimestamp);
    }

    // ── Rate Limiting ─────────────────────────────────────────────────────────

    #[test]
    fn test_rate_limit_within_bounds() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        for _ in 0..10 {
            assert!(client.check_rate_limit(&caller).is_ok());
        }
    }

    #[test]
    fn test_rate_limit_exceeded() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        for _ in 0..10 {
            client.check_rate_limit(&caller).unwrap();
        }
        let result = client.check_rate_limit(&caller);
        assert_eq!(result.unwrap_err(), ExploitError::RateLimitExceeded);
    }

    #[test]
    fn test_rate_limit_independent_callers() {
        let (env, client, _, _) = setup_initialized();
        let caller_a = Address::generate(&env);
        let caller_b = Address::generate(&env);
        for _ in 0..10 {
            client.check_rate_limit(&caller_a).unwrap();
        }
        // caller_b should still succeed
        assert!(client.check_rate_limit(&caller_b).is_ok());
    }

    // ── RNG Proof Validation ──────────────────────────────────────────────────

    #[test]
    fn test_rng_proof_valid() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        let game_id: u64 = 12345;
        let vrf_output: BytesN<32> = BytesN::from_array(&env, &[7u8; 32]);

        // Compute the expected proof = SHA-256(game_id_be || vrf_output)
        let mut preimage = Bytes::new(&env);
        preimage.extend_from_array(&game_id.to_be_bytes());
        preimage.append(&Bytes::from_slice(&env, vrf_output.as_ref()));
        let vrf_proof: BytesN<32> = env.crypto().sha256(&preimage);

        assert!(client
            .validate_rng_proof(&caller, &game_id, &vrf_output, &vrf_proof)
            .is_ok());
    }

    #[test]
    fn test_rng_proof_invalid() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        let vrf_output: BytesN<32> = BytesN::from_array(&env, &[7u8; 32]);
        let bad_proof: BytesN<32> = BytesN::from_array(&env, &[0u8; 32]);
        let result = client.validate_rng_proof(&caller, &42u64, &vrf_output, &bad_proof);
        assert_eq!(result.unwrap_err(), ExploitError::InvalidRngProof);
    }

    // ── Oracle Data Validation ────────────────────────────────────────────────

    #[test]
    fn test_oracle_data_valid() {
        let (env, client, _, oracle) = setup_initialized();
        let round_id: u64 = 1;
        let data = Bytes::from_slice(&env, b"price:100");

        let mut preimage = Bytes::new(&env);
        preimage.extend_from_array(&round_id.to_be_bytes());
        preimage.append(&data);
        let sig: BytesN<32> = env.crypto().sha256(&preimage);

        assert!(client
            .validate_oracle_data(&oracle, &round_id, &data, &sig)
            .is_ok());
    }

    #[test]
    fn test_oracle_data_tampered() {
        let (env, client, _, oracle) = setup_initialized();
        let data = Bytes::from_slice(&env, b"price:100");
        let bad_sig: BytesN<32> = BytesN::from_array(&env, &[0u8; 32]);
        let result = client.validate_oracle_data(&oracle, &1u64, &data, &bad_sig);
        assert_eq!(result.unwrap_err(), ExploitError::OracleDataTampered);
    }

    #[test]
    fn test_oracle_unauthorized_caller() {
        let (env, client, _, _) = setup_initialized();
        let rando = Address::generate(&env);
        let data = Bytes::from_slice(&env, b"price:100");
        let sig: BytesN<32> = BytesN::from_array(&env, &[0u8; 32]);
        let result = client.validate_oracle_data(&rando, &1u64, &data, &sig);
        assert_eq!(result.unwrap_err(), ExploitError::NotOracle);
    }

    // ── Settlement Validation ─────────────────────────────────────────────────

    #[test]
    fn test_settlement_valid() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        // pool=100, in=80, out=70, payout=70
        assert!(client
            .validate_settlement(&caller, &100i128, &80i128, &70i128, &70i128)
            .is_ok());
    }

    #[test]
    fn test_settlement_out_exceeds_in() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        let result = client.validate_settlement(&caller, &1000i128, &50i128, &100i128, &50i128);
        assert_eq!(result.unwrap_err(), ExploitError::SettlementManipulated);
    }

    #[test]
    fn test_settlement_payout_exceeds_pool() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        let result = client.validate_settlement(&caller, &10i128, &100i128, &80i128, &50i128);
        assert_eq!(result.unwrap_err(), ExploitError::InsufficientBalance);
    }

    #[test]
    fn test_settlement_negative_values_rejected() {
        let (env, client, _, _) = setup_initialized();
        let caller = Address::generate(&env);
        let result = client.validate_settlement(&caller, &100i128, &(-1i128), &50i128, &10i128);
        assert_eq!(result.unwrap_err(), ExploitError::InvalidInput);
    }

    // ── Bounds Update ─────────────────────────────────────────────────────────

    #[test]
    fn test_update_bounds_admin_only() {
        let (env, client, admin, _) = setup_initialized();
        let new_config = BoundConfig {
            min_amount: 5_000_000,
            max_amount: 50_000_000_000,
            max_timestamp_delta: 600,
            rate_limit_window: 120,
            rate_limit_max_calls: 20,
        };
        assert!(client.update_bounds(&admin, &new_config).is_ok());

        let rando = Address::generate(&env);
        let result = client.update_bounds(&rando, &new_config);
        assert_eq!(result.unwrap_err(), ExploitError::NotAdmin);
    }
}