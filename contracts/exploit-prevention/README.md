# exploit-prevention

Reusable exploit-prevention guards for the Stellarcade platform, implemented as a Soroban smart contract on the Stellar network.

---

## Overview

This contract provides a composable security layer that other Stellarcade contracts call into before performing any privileged or value-bearing operation. It is intentionally stateless from the perspective of game logic—it knows nothing about game state—so it can be upgraded or replaced without disrupting the prize pool or RNG contracts.

---

## Methods

### Initialization

#### `initialize(admin, oracle, config) → Result<(), ExploitError>`

Initializes the contract. **Can only be called once.** Sets the admin, oracle, and `BoundConfig`. Emits `("exploit", "init")`.

#### `update_bounds(caller, config) → Result<(), ExploitError>`

Admin-only. Updates the `BoundConfig` (min/max amounts, timestamp delta, rate limits). Emits `("exploit", "bnd_upd")`.

---

### Admin & Access Control

#### `change_admin(caller, new_admin) → Result<(), ExploitError>`

Transfers the admin role. Only the current admin can call this. Emits `("exploit", "adm_chg")`.

#### `set_oracle(caller, new_oracle) → Result<(), ExploitError>`

Admin-only. Updates the trusted oracle address.

---

### Emergency Pause (Circuit Breaker)

#### `pause(caller) → Result<(), ExploitError>`

Admin-only. Pauses all non-admin operations. Emits `("exploit", "paused")`.

#### `unpause(caller) → Result<(), ExploitError>`

Admin-only. Resumes operations. Emits `("exploit", "unpaused")`.

---

### Replay Protection

#### `consume_nonce(nonce: u64) → Result<(), ExploitError>`

Marks a nonce as consumed. Returns `NonceReused` if already seen. Emits `("exploit", "rply_blk")` on duplicate. Nonces are stored in persistent storage with a 7-day TTL.

#### `consume_tx_hash(hash: BytesN<32>) → Result<(), ExploitError>`

Marks a 32-byte transaction hash as processed. Returns `AlreadyProcessed` on duplicate. Emits `("exploit", "rply_blk")` on duplicate.

---

### Input Bounds Validation

#### `check_amount(amount: i128) → Result<(), ExploitError>`

Validates `amount` against the configured `[min_amount, max_amount]` range. Emits `("exploit", "bnd_viol")` on violation.

#### `check_timestamp(timestamp: u64) → Result<(), ExploitError>`

Validates that `timestamp` is within the staleness window (`max_timestamp_delta` seconds). Rejects timestamps more than 30 seconds in the future.

---

### Rate Limiting

#### `check_rate_limit(caller: Address) → Result<(), ExploitError>`

Records a call for `caller`. Returns `RateLimitExceeded` if the caller has exceeded `rate_limit_max_calls` within `rate_limit_window` seconds. Emits `("exploit", "rt_lmt")` on limit exceeded. Uses a sliding-window counter stored in temporary storage.

---

### Randomness Integrity

#### `validate_rng_proof(caller, game_id, vrf_output, vrf_proof) → Result<(), ExploitError>`

Verifies that `vrf_proof == SHA-256(game_id_be || vrf_output)`. Returns `InvalidRngProof` on mismatch. Emits `("exploit", "rng_ok")` or `("exploit", "rng_rej")`.

> **Production note:** Replace the SHA-256 commitment with a full VRF verification using the oracle's Ed25519 public key stored on-chain.

---

### Oracle Data Integrity

#### `validate_oracle_data(oracle_caller, round_id, data, signature) → Result<(), ExploitError>`

Oracle-only. Verifies `signature == SHA-256(round_id_be || data)`. Returns `OracleDataTampered` on mismatch or `NotOracle` if the caller is not the registered oracle. Emits `("exploit", "orc_ok")` or `("exploit", "orc_rej")`.

---

### Settlement Validation

#### `validate_settlement(caller, pool_balance, total_in, total_out, payout) → Result<(), ExploitError>`

Validates that:
- All values are non-negative.
- `total_out <= total_in` (no funds created from nothing).
- `payout <= pool_balance` (solvency invariant).
- `pool_balance - payout >= 0` (no arithmetic underflow).

Emits `("exploit", "stl_ok")` or `("exploit", "stl_rej")`.

---

### Getters

| Method | Returns |
|---|---|
| `get_admin()` | `Address` |
| `is_paused()` | `bool` |
| `get_bound_config()` | `BoundConfig` |
| `is_nonce_consumed(nonce)` | `bool` |
| `is_tx_hash_consumed(hash)` | `bool` |

---

## Events

All events have the topic structure `("exploit", <event_name>)`.

| Event | Data | Trigger |
|---|---|---|
| `"init"` | `(admin,)` | Contract initialized |
| `"adm_chg"` | `(old_admin, new_admin)` | Admin transferred |
| `"paused"` | `(admin,)` | Contract paused |
| `"unpaused"` | `(admin,)` | Contract unpaused |
| `"bnd_upd"` | `()` | Bounds config updated |
| `"rply_blk"` | `(nonce_or_hash,)` | Replay attempt blocked |
| `"bnd_viol"` | `(amount, min, max)` | Amount out of bounds |
| `"rt_lmt"` | `(caller,)` | Rate limit exceeded |
| `"rng_ok"` | `(game_id,)` | RNG proof valid |
| `"rng_rej"` | `(game_id,)` | RNG proof invalid |
| `"orc_ok"` | `(round_id,)` | Oracle data valid |
| `"orc_rej"` | `(round_id,)` | Oracle data tampered |
| `"stl_ok"` | `(total_in, total_out)` | Settlement valid |
| `"stl_rej"` | `(total_in, total_out)` | Settlement rejected |

---

## Storage

| Key | Type | Storage Tier | TTL |
|---|---|---|---|
| `Admin` | `Address` | Instance | Contract lifetime |
| `Oracle` | `Address` | Instance | Contract lifetime |
| `Paused` | `bool` | Instance | Contract lifetime |
| `BoundConfig` | `BoundConfig` | Instance | Contract lifetime |
| `Nonce(u64)` | `bool` | Persistent | 7 days |
| `TxHash(BytesN<32>)` | `bool` | Persistent | 7 days |
| `RateLimit(Address)` | `RateLimitEntry` | Temporary | Rate-limit window |

---

## Error Codes

| Code | Value | Description |
|---|---|---|
| `Unauthorized` | 1 | General auth failure |
| `NotAdmin` | 2 | Caller is not the admin |
| `NotOracle` | 3 | Caller is not the oracle |
| `AlreadyProcessed` | 10 | TX hash already consumed |
| `NonceReused` | 11 | Nonce already consumed |
| `InvalidInput` | 20 | Bad parameter |
| `AmountTooLow` | 21 | Amount below minimum |
| `AmountTooHigh` | 22 | Amount above maximum |
| `StaleTimestamp` | 24 | Timestamp outside window |
| `InvalidStateTransition` | 30 | Reserved |
| `AlreadyInitialized` | 31 | `initialize` called twice |
| `NotInitialized` | 32 | Contract not initialized |
| `ContractPaused` | 33 | Operations paused |
| `ArithmeticOverflow` | 40 | Checked arithmetic failed |
| `InsufficientBalance` | 41 | Payout exceeds pool balance |
| `AccountingInvariant` | 42 | Accounting invariant violated |
| `InvalidRngProof` | 50 | VRF proof mismatch |
| `OracleDataTampered` | 51 | Oracle signature mismatch |
| `SettlementManipulated` | 52 | total_out > total_in |
| `RateLimitExceeded` | 60 | Too many calls in window |

---

## BoundConfig Fields

```rust
pub struct BoundConfig {
    pub min_amount: i128,          // Minimum wager in stroops
    pub max_amount: i128,          // Maximum wager in stroops
    pub max_timestamp_delta: u64,  // Staleness window in seconds
    pub rate_limit_window: u64,    // Sliding window size in seconds
    pub rate_limit_max_calls: u32, // Max calls per window per address
}
```

---

## Invariants

1. **Solvency**: `payout <= pool_balance` at all times.
2. **Conservation**: `total_out <= total_in` within any settlement round.
3. **Deduplication**: Each nonce and TX hash can be consumed at most once.
4. **Monotonic pause**: Only admin can toggle pause state.
5. **Single admin**: At most one admin address exists at any time.
6. **Oracle integrity**: Only the registered oracle can submit price/randomness data.
7. **No future timestamps**: Timestamps > `now + 30s` are rejected.

---

## Integration Assumptions

- **Prize Pool contract** must call `consume_nonce`, `check_amount`, `validate_settlement`, and `check_rate_limit` before processing any wager or payout.
- **RNG contract** must call `validate_rng_proof` before using any VRF output for game settlement.
- **Oracle feeder service** must call `validate_oracle_data` via the oracle account before submitting price data.
- **All contracts** should check `is_paused()` or call through this contract's guarded methods so a single `pause()` from admin halts the entire platform.
- This contract **does not store game state**. It is a pure guard layer.
- The `BoundConfig` is shared platform-wide; game-specific overrides should be handled in each game contract after calling this guard.